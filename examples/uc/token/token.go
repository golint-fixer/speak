// generated by speak; DO NOT EDIT.

// Package token defines constants representing the lexical tokens of the source
// language.
package token

import "fmt"

// A Token represents a lexical token of the source language.
type Token struct {
	// Start position in the source input.
	Pos int
	// Token type.
	ID ID
	// Token literal.
	Lit []byte
}

// String returns the string represenatation of the token.
func (tok *Token) String() string {
	return fmt.Sprintf("Pos: %d, ID: %s, Lit: %q", tok.Pos, tok.ID, tok.Lit)
}

// ID is the set of lexical tokens of the source language.
type ID int

// Minimum and maximum token ID for each category of tokens, as specified by the
// language grammar.
const (
	minName  ID = 0
	maxName  ID = 2
	minToken ID = 3
	maxToken ID = 28
	minSkip  ID = 29
	maxSkip  ID = 30
)

// String returns the string represenatation of the token ID.
func (id ID) String() string {
	if int(id) < len(IDs) {
		return IDs[id]
	}
	return fmt.Sprintf("<unknown token ID %d>", int(id))
}

// IsName reports whether the given token ID is represented by a production name
// in the language grammar.
func (id ID) IsName() bool {
	return minName <= id && id <= maxName
}

// IsToken reports whether the given token ID is represented by a token literal
// in the language grammar.
func (id ID) IsToken() bool {
	return minToken <= id && id <= maxToken
}

// IsSkip reports whether the given token ID is part of the ignored set of
// tokens in the language grammar.
func (id ID) IsSkip() bool {
	return minSkip <= id && id <= maxSkip
}

// IDs specifies the string representation of each token ID.
var IDs = [...]string{
	"name(0, `char_lit`)",
	"name(1, `ident`)",
	"name(2, `int_lit`)",
	"token(3, `!`)",
	"token(4, `!=`)",
	"token(5, `&&`)",
	"token(6, `(`)",
	"token(7, `)`)",
	"token(8, `*`)",
	"token(9, `+`)",
	"token(10, `,`)",
	"token(11, `-`)",
	"token(12, `/`)",
	"token(13, `;`)",
	"token(14, `<`)",
	"token(15, `<=`)",
	"token(16, `=`)",
	"token(17, `==`)",
	"token(18, `>`)",
	"token(19, `>=`)",
	"token(20, `[`)",
	"token(21, `]`)",
	"token(22, `else`)",
	"token(23, `if`)",
	"token(24, `return`)",
	"token(25, `typedef`)",
	"token(26, `while`)",
	"token(27, `{`)",
	"token(28, `}`)",
	"skip(29, `comment`)",
	"skip(30, `whitespace`)",
}
