// A grammar for the µC programming language [1].
//
// The content and structure of this document is heavily influenced by the Go
// Programming Language Specification [2] and some parts are therefore governed
// by a BSD-style license [3]. Any original content of this document is hereby
// released into the public domain [4].
//
// References:
//    [1]: https://www.it.uu.se/katalog/aleji304/CompilersProject/uc.html
//    [2]: http://golang.org/ref/spec
//    [3]: http://golang.org/LICENSE
//    [4]: https://creativecommons.org/publicdomain/zero/1.0/

// # Source code representation
//

// ## Characters
//

// An arbitrary ASCII character except null (0x00), new lines (0x0A), carriage
// return (0x0D), apostrophe (0x27), double quote (0x22) and backslash (0x5C).
//_ascii_char
//	= "\x01" … "\x09"
//	| "\x0B" … "\x0C"
//	| "\x0E" … "\x21"
//	| "\x23" … "\x26"
//	| "\x28" … "\x5B"
//	| "\x5D" … "\x7F"
//.

_ascii_letter = "a" … "z" | "A" … "Z" .
_ascii_digit  = "0" … "9" .

// ## Letters and digits
//

_letter        = _ascii_letter | "_" .
_decimal_digit = _ascii_digit .
_decimals      = _decimal_digit { _decimal_digit } .

// # Lexical elements
//

// ## Comments
//

_not_newline = "\x00" … "\x09" | "\x0B" … "\U0010FFFF" .
_not_star = "\x00" … "\x29" | "\x2B" … "\U0010FFFF" .

_line_comment
	= "/" "/" { _not_newline } "\n"
	// TODO: Implement proper support for preprocess directive.
	| "#"  { _not_newline } "\n"
.
_block_comment = "/" "*" { _not_star } "*" "/" .
comment        = _line_comment | _block_comment .

// ## Tokens
//

// White space, formed from spaces (0x20), horizontal tabs (0x09), new line
// (line-feed (0x0A) or carriage-return (0x0D)), vertical tabs (0x0B), and form-
// feeds (0x0C) (§6.4), is ignored except as it separates tokens that would
// otherwise combine into a single token.
whitespace = " " | "\t" | "\v" | "\f" | "\r" | "\n" .

// ## Identifiers
//

ident = _letter { _letter | _decimal_digit } .

// ## Integer literals
//

int_lit = _decimals .

// ## Character literals
//

_escaped_char = "\\" "n" .
//char_lit      = "'" ( _ascii_char | "\"" | _escaped_char ) "'" .
char_lit = "'" ( _escaped_char | "a" ) "'" .
//_char = _escaped_char | "a" .
//char_lit = "'" _char "'" .

// # Syntaxic production rules
//

File
	= Decls
.

Decls = [ DeclList ] .

DeclList
	= Decl
	| DeclList Decl
.

Decl
	= VarDecl ";"
	| FuncDecl ";"
	| FuncDef
	| TypeDef ";"
.

FuncDecl
	= FuncHeader
.

FuncHeader
	// BasicType : "char" | "int" | "void" ;
	= BasicType ident "(" Params ")"
.

FuncDef
	= FuncHeader BlockStmt
.

VarDecl
	= ScalarDecl
	| ArrayDecl
.

ScalarDecl
	// BasicType : "char" | "int" ;
	= BasicType ident
.

ArrayDecl
	// BasicType : "char" | "int" ;
	= BasicType ident "[" IntLit "]"
	| BasicType ident "[" "]"
.

IntLit
	= int_lit
	| char_lit
.

TypeDef
	= "typedef" Type ident
.

BasicType
	// BasicType : "char" | "int" | "void" ;
	= ident
.

Params = [ ParamList ] .

ParamList
	= Param
	| ParamList "," Param
.

Param
	// BasicType : "void" ;
	= Type
	| VarDecl
.

// TODO: Add support for array types.
Type
	= BasicType
.

Stmt
	= MatchedStmt
	| OpenStmt
.

// Thanks to http://www.parsifalsoft.com/ifelse.html for loop statement
// resolvning (while, do, for).

OtherStmt
	= Expr ";"
	| "return" Expr ";"
	| "return" ";"
	| BlockStmt
	| ";"
.

BlockStmt
	= "{" BlockItems "}"
.

MatchedStmt
	= "if" Condition MatchedStmt
	  "else" MatchedStmt
	| "while" Condition MatchedStmt
	| OtherStmt
.

OpenStmt
	= "if" Condition Stmt
	| "if" Condition MatchedStmt
	  "else" OpenStmt
	| "while" Condition OpenStmt
.

Condition
	= "(" Expr ")"
.

BlockItems = [ BlockItemList ] .

BlockItemList
	= BlockItem
	| BlockItemList BlockItem
.

BlockItem
	= Decl
	| Stmt
.

Expr
	= Expr2R
.

// Right-associative binary expressions with precedence 2.
//
//    2R: =
Expr2R
	= Expr5L
	// Right-associative.
	| Expr5L "=" Expr2R
.

// Left-associative binary expressions with precedence 5.
//
//    5L: &&
Expr5L
	= Expr9L
	| Expr5L "&&" Expr9L
.

// Left-associative binary expressions with precedence 9.
//
//    9L: == !=
Expr9L
	= Expr10L
	| Expr9L "==" Expr10L
	| Expr9L "!=" Expr10L
.

// Left-associative binary expressions with precedence 10.
//
//    10L: < > <= >=
Expr10L
	= Expr12L
	| Expr10L "<" Expr12L
	| Expr10L ">" Expr12L
	| Expr10L "<=" Expr12L
	| Expr10L ">=" Expr12L
.

// Left-associative binary expressions with precedence 12.
//
//    12L: + -
Expr12L
	= Expr13L
	| Expr12L "+" Expr13L
	| Expr12L "-" Expr13L
.

// Left-associative binary expressions with precedence 13.
//
//    13L: * /
Expr13L
	= Expr14
	| Expr13L "*" Expr14
	| Expr13L "/" Expr14
.

// Unary expressions with precedence 14.
//
//    14: - !
Expr14
	= Expr15
	| "-" Expr14
	| "!" Expr14
.

// TODO: Replace function name with expression in call expression. Do the same
// for array names.

// TODO: Replace Expr15 (and similar names) with CastExpr, PostfixExpr, ...
// (from the C11 spec).

// Expressions with precedence 15.
Expr15
	= PrimaryExpr
	| ident "[" Expr "]"
	| ident "(" Args ")"
.

// Primary expressions with the highest precedence (§A.2.1).
PrimaryExpr
	= int_lit
	| char_lit
	| ident
	| ParenExpr
.

ParenExpr
	= "(" Expr ")"
.

Args = [ ExprList ] .

ExprList
	= Expr
	| ExprList "," Expr
.
